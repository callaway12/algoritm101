B311048 김태완

알고리즘 분석 2분반

정렬 알고리즘의 실행시간 비교

총 3가지의 정렬 알고리즘을 비교했습니다.

교환정렬, 병합정렬, 퀵정렬 을 비교했습니다.

교환정렬의 경우 키값을 두가지로 하나랑 다른 하나는 전체를 돌며 비교하는 알고리즘을 이용했습니다.
시간복잡도의 경우 n^2의 복잡도를 보입니다.

합병정렬의 경우 우선적으로 중간을 기점으로 계속 절반으로 나누면서 잘게 쪼개서 하나가 암을떄까지 쪼개고
그것을 비교하여 다시 합치는것으로 했습니다. 시간복잡도의 경우 n log n 의 복잡도를 보인다고 알고있습니다.

퀵정렬의 경우 가장 우수하다고 알고 있고 algorithm 라이브러리에 기본적으로 탑재되어있느니 만큼 자주 사용하는 정렬방법입니다.
이또한 nlogn의 평균적인 성능을 보이지만 최악의 경우 아주 높은 복잡도를 나타냅니다. 
그에따라 정렬된 데이터값들을 받아서 정렬할 경우 하단의 무작위로 선택된 배열에비해 대략적으로 10배에 가까운 시간복잡도를 나타냈습니다.

확실히 교환정렬의 경우 알고리즘 자체의 성능으로 인해 어떠한 배열을 받더라도 매우 느린 속도를 나타내며
퀵정렬의 경우 알고리즘에 의해 정렬된 값이 주어진다면 피봇값으로 처음 받은 값으로 했기에 아주 느린 속도를 나타냅니다.
이의 경우 피봇값을 중간으로 잡으면 조금은 나아진 성능을 보일 수 있다고 보여집니다.

하단의 무작위 데이터들을 생성하는 함수를 ran_num_input으로 각각의 3가지 값을 받아서
3가지의 크기의 무작위 데이터들을 시간함수를 이용하여 키값을 받아서 생성했습니다.
또한 같은 데이터들을 이용하여 정렬 알고리즘을 비교해야하기에 각각에 해당하는 총 9가지의 배열을 2세트를 동일하게 만들어 실험했습니다.

이에반해 상단의 정렬된 데이터들은 그냥 for문을 돌면서 1부터 증가하는 값을 이용하여 원하는 크기의 데이터들을 1부터 생성되게 했습니다.

실험은 high_resolution_clock::time_point t = high_resolution_clock::now(); 를 이용하여 시간 측정의 정확도를 높혔습니다. 

위와같은 실험을 통해 알 수 있는 점은 보통 안정적인 성능을 보여준다고 알려진 퀵소트의 경우 정렬된 데이터들이 입력받는다면 최악의 시간복잡도를 보일 수 있음을 알게되었습니다.
또한 일반적인 무작위의 데이터의 경우 합병정렬보다 퀵정렬이 조금은 더 빠른 속도를 보인다는 것을 알 수 있었습니다.
